# -*- coding: utf-8 -*-
"""python-eda-stack-overflow-survey.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VkUmCyLhGcjySVQcRLt3voRqUaQaOkXu
"""

pip install opendatasets

import opendatasets as od

od.download('stackoverflow-developer-survey-2020')

import os

os.listdir('./stackoverflow-developer-survey-2020')

import pandas as pd

survey_raw_df = pd.read_csv('/content/stackoverflow-developer-survey-2020/survey_results_public.csv')
survey_raw_df

survey_raw_df.columns

survey_raw_df['ConvertedComp']

schema_fname = '/content/stackoverflow-developer-survey-2020/survey_results_schema.csv'
pd.read_csv(schema_fname, index_col='Column').QuestionText

schema_raw = pd.read_csv(schema_fname, index_col='Column').QuestionText

schema_raw

schema_raw['YearsCodePro']

"""Data Preparation & Cleaning"""

selected_columns = [
    #Demographics
    'Country',
    'Age',
    'Gender',
    'EdLevel',
    'UndergradMajor',

    #Coding experience
    'Hobbyist',
    'Age1stCode',
    'YearsCode',
    'YearsCodePro',
    'LanguageWorkedWith',
    'LanguageDesireNextYear',
    'NEWLearn',
    'NEWStuck',

    #Employement
    'Employment',
    'DevType',
    'WorkWeekHrs',
    'JobSat',
    'JobFactors',
    'NEWOvertime',
    'NEWEdImpt',
    'ConvertedComp'
]

len(selected_columns)

survey_df = survey_raw_df[selected_columns].copy()

schema = schema_raw[selected_columns]
schema.shape

survey_df

survey_df.shape

survey_df.info()

schema.Age1stCode

schema.YearsCode

survey_df.YearsCode.unique()

survey_df.Age1stCode.unique()

survey_df['Age1stCode'] = pd.to_numeric(survey_df.Age1stCode, errors='coerce')
survey_df['YearsCode'] = pd.to_numeric(survey_df.Age1stCode, errors='coerce')
survey_df['YearsCodePro'] = pd.to_numeric(survey_df.Age1stCode, errors='coerce')

survey_df.describe()

survey_df[survey_df.Age < 10].index       #the ourput is row numbers containing these values

survey_df.drop(survey_df[survey_df.Age < 10].index, inplace=True)

survey_df.drop(survey_df[survey_df.Age > 100].index, inplace=True)

survey_df.describe()

survey_df.drop(survey_df[survey_df.WorkWeekHrs > 140].index, inplace=True)
survey_df

schema.Gender

survey_df['Gender'].value_counts()

import numpy as np

# survey_df.where(~(survey_df.Gender.isin(['Male', 'Female', 'Other'])), np.nan, inplace=True)
survey_df.where(~(survey_df.Gender.str.contains(';', na=False)), np.nan, inplace=True)

survey_df['Gender'].value_counts()

survey_df

survey_df.sample(10)   #sample data

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
# %matplotlib inline

sns.set_style('darkgrid')
matplotlib.rcParams['font.size'] = 14
matplotlib.rcParams['figure.figsize'] = (9, 5)
matplotlib.rcParams['figure.facecolor'] = '#00000000'

schema.Country

top_countries = survey_df.Country.value_counts().head(15)
top_countries

plt.figure(figsize=(12,6));
plt.xticks(rotation=45);
plt.title(schema.Country);
sns.barplot(x=top_countries.index, y=top_countries, hue=top_countries.index, palette='viridis' );

"""**Exercise 1**


It appears the that a disproportionately high number of respondents are from USA & India - which one might expect since these countries have the highest populations (apart from China), and since the Survey is in English, which is the common language used by professionals in US, India & UK. We can already see that the survey may not be representative of the entire programming community - especially from non-English speaking countries.
Exercise : Try finding the percentage of responses from
English speaking vs Non English speaking countries. You can use this csv
"""

languages_df = pd.read_csv('https://raw.githubusercontent.com/jvcasillas/worldlanguages/refs/heads/main/data-raw/languages_by_country_2022-12-13.csv')
languages_df

languages_df.info()

english_speaking_countries = languages_df[languages_df['official_language'].str.contains('English')]['country_region'].unique()

survey_df['is_English_speaking'] = survey_df['Country'].apply(lambda x : 'English-Speaking' if x in english_speaking_countries else 'Non-English-Speaking')
survey_df

percentages_responses = survey_df.is_English_speaking.value_counts(normalize= True) * 100

print(f'Percentage of responses by country type: {percentages_responses}')

sns.set_style('whitegrid')
plt.figure(figsize=(8,9))
sns.barplot(x=percentages_responses.index, y=percentages_responses, hue=percentages_responses.index, palette='viridis');
plt.title('Percentage of Responses by Country Type');
plt.xlabel('Country Type');
plt.ylabel('Percentage');

for index, value in enumerate(percentages_responses):
  plt.text(index, value + 0.5, f'{value:2f}%', ha='center', va='bottom')
plt.ylim(0, 100)
plt.show()

plt.figure(figsize=(12,6));
plt.title(schema.Age);
plt.xlabel('Age');
plt.ylabel('Number of Respondents');

plt.hist(survey_df.Age, bins=np.arange(10, 100, 5), color='purple');

"""**Exercise 2**

It appears that a large percentage of respondents are in the age range of 20-45, which is somewhat representative of the programming community in general, as a lot of young people have taken up computer as their field of study or profession in the last 20 years.

Exercise : You may want to filter out responses by age (or age group) , if you'd like to analyze and compare the results of the survey for different age groups.
Create a new column called AgeGroup which contains values like 'Less than 10 Years', '10-18 Years', '18-30 Years', 30-45 Years', '45-60 Years', 'Older tha  60 Years' and repeat the analysis for rest of this notebook for each age group.
"""

bins = [0,10,18,30,45,60, np.inf]
labels =['Less than 10 Years', '10-18 Years', '18-30 Years', '30-45 Years', '45-60 Years', 'Older than 60 Years']

survey_df['AgeGroup'] = pd.cut(
    survey_df['Age'],
    bins=bins,
    labels=labels,
    right=False,
    include_lowest=True
    )

print('Suvery dataframe with the new Age Group column:')
print(survey_df[['Age', "AgeGroup"]].head())

agegroup_counts = survey_df.AgeGroup.value_counts()
agegroup_counts.sort_index(inplace=True)
agegroup_counts

plt.figure(figsize=(10,6));
plt.title('The results of the survey for different age groups');
plt.xlabel('Age Group');
plt.ylabel('Number of Respondents');
sns.barplot(x=agegroup_counts.index, y=agegroup_counts.values, hue=agegroup_counts.index, palette='turbo')     #magma, inferno, plasma, cividis, mako, rocket, and turbo
plt.xticks(rotation=45);
for index, values in enumerate(agegroup_counts.values):
  plt.text(index, values + 50, str(values), ha='center', va='bottom')
plt.tight_layout()
plt.show()

schema.Gender

gender_counts = survey_df.Gender.value_counts(dropna=False)
gender_counts

plt.figure(figsize=(12,6));
plt.title(schema.Gender);
plt.pie(gender_counts, labels=gender_counts.index, autopct='%1.1f%%', startangle=180, colors=sns.color_palette('dark'));

"""**Exercise 3**


Only about 8% of survey respondents who have answered the question identify as women or non-binary. This number is lower than the overall percentage of women & non-binary genders in the programming community - which is estimated to be around 12%.

Exercise: It would be interesting to compare the survey responses & preferences across genders, and you are encouraged to repeat this analysis with these breakdowns. How do the relative education levels differ across genders? How to salaries differ? You may find this analysis on the Gender Divide in Data Science useful.

*1. Education Level Analysis*
"""

filtered_gender_df = survey_df.dropna(subset=['Gender'])
filtered_gender_df= filtered_gender_df[~filtered_gender_df.Gender.str.contains(';', na=False)]
filtered_gender_df

plt.figure(figsize=(15,6))
sns.countplot(
    x='EdLevel',
    hue='Gender',
    data=filtered_gender_df,
    palette='Set2'
);
plt.title('Education Levels by Gender');
plt.xlabel('Education Level');
plt.ylabel('Number of Respondents');
plt.xticks(rotation=45, ha='right');
plt.tight_layout();
plt.show();

"""*2. Salary Analysis*"""

salary_df = survey_df.dropna(subset=['ConvertedComp', 'Gender']).copy()
salary_df

salary_df = salary_df[salary_df['ConvertedComp'] > 1000]

salary_df['Gender'] = salary_df['Gender'].apply(
    lambda x: 'Man' if x=='Man' else ('Woman' if x == 'Woman' else 'Other')
)

plt.figure(figsize=(12, 8))
sns.set_style("whitegrid")

# Create a box plot to show the distribution of salaries across gender
sns.boxplot(
    x='Gender',
    y='ConvertedComp',
    data=salary_df,
    palette='magma'
)

plt.title('Median Salary Comparison by Gender')
plt.xlabel('Gender')
plt.ylabel('Annual Compensation (USD)')
plt.yscale('log') # Use a log scale to handle large salary differences
plt.show()

# To get the exact median values, you can use groupby
median_salaries = salary_df.groupby('Gender')['ConvertedComp'].median()
print("Median Salaries by Gender:")
print(median_salaries)

"""**Exercise 4**

It appears that well over half of the respondents hold a bachelor's or master's degree, so most programmers definitely seem to have some college education, although it's not clear from this graph alone if they hold a degree in computer science.

Exercises: The graph currently shows the number of respondents for each option, can you modify it to show the percentage instead? Further, can you break down the graph to compare the percentages for each degree for men vs. women.
"""

schema.EdLevel

survey_df.EdLevel.unique()

plt.figure(figsize=(12,6));
sns.countplot(y=survey_df.EdLevel);
plt.xticks(rotation=75);
plt.title(schema['EdLevel']);
plt.ylabel(None);

edLevel_percentages = survey_df.EdLevel.value_counts(normalize=True)*100
edLevel_percentages = edLevel_percentages.sort_values(ascending=False)
edLevel_percentages

plt.figure(figsize=(12,6))
sns.barplot(x=edLevel_percentages.values, y=edLevel_percentages.index, palette='viridis');
plt.title(schema['EdLevel'])
plt.xlabel('Percentage %')
plt.ylabel('Education Level')

for index, value in enumerate(edLevel_percentages.values):
  plt.text(value, index, f'{value:.1f}%', va='center')

plt.tight_layout()
plt.show

gender_map = {
    'Man': 'Man',
    'Woman': 'Woman',
    'Non-binary, genderqueer, or gender non-conforming': 'Other'
}

filtered_df = survey_df.dropna(subset=['EdLevel','Gender']).copy()
filtered_df['GenderCleaned'] = filtered_df['Gender'].map(gender_map).fillna('Other')

edlevel_by_gender = pd.crosstab(
    index=filtered_df['EdLevel'],
    columns=filtered_df['GenderCleaned'],
    normalize='index'
)*100

edlevel_by_gender.plot(kind='bar', figsize=(15,8), stacked=False)
plt.title('Education Level Percentages by Gender')
plt.xlabel('Education Level')
plt.ylabel('Percentage %')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Gender')
plt.tight_layout()
plt.show()

print('Education Level Percentages by Gender:')
print(edlevel_by_gender)

schema.UndergradMajor

undergrad_pct = survey_df.UndergradMajor.value_counts()*100 / survey_df.UndergradMajor.count()
undergrad_pct

sns.barplot(x=undergrad_pct, y=undergrad_pct.index, hue=undergrad_pct, palette='turbo');
plt.title(schema.UndergradMajor);
plt.ylabel(None);
plt.xlabel('Percentage');

"""**Exercise 5**

It turns that 40% of programmers holding a college degree have a field of study other than computer science - which is very encouraging. This seems to suggest that while college education is helpful in general, you do not need to pursue a major in computer science to become a successful programmer.

Exercises: Analyze the results of the NEWEdImpt column for respondents who hold some college degree vs. those who don't. Do you notice any difference in opinion?
"""

survey_df['NEWEdImpt']

survey_df

survey_df['EdLevel']

college_degrees = [
     'Master’s degree (M.A., M.S., M.Eng., MBA, etc.)',
    'Bachelor’s degree (B.A., B.S., B.Eng., etc.)',
    'Professional degree (JD, MD, etc.)',
    'Associate degree (A.A., A.S., etc.)',
    'Other doctoral degree (Ph.D., Ed.D., etc.)',
]

survey_df['HasCollegeDegree'] = np.where(survey_df['EdLevel'].isin(college_degrees), 'Some College Degree', 'No College Degree')

plot_df = survey_df.dropna(subset=['NEWEdImpt', 'HasCollegeDegree'])
plot_df

plt.figure(figsize=(15, 8))
sns.countplot(
    hue='HasCollegeDegree',
    y='NEWEdImpt',
    data=plot_df,
    order=plot_df['NEWEdImpt'].value_counts().index,
    palette='magma'
)
plt.title('Importance of formal educaton by college degree status')
plt.xlabel('Number of respondents')
plt.ylabel('Importamce of formal education')
plt.legend(title='College Degree Status')
plt.tight_layout()
plt.show()


ed_impt_by_degree = pd.crosstab(
    index=plot_df['NEWEdImpt'],
    columns=plot_df["HasCollegeDegree"],
    normalize='index'
)*100
print('Percentage breakdown of opinions:')
print(ed_impt_by_degree )

schema.Employment

(survey_df.Employment.value_counts(normalize=True, ascending=True)*100).plot(kind='barh', color='g', figsize=(10,6));
plt.title(schema.Employment)
plt.xlabel('Percentage');
plt.ylabel('Employment Type');
plt.show();

"""**Exercise 6**

It appears that close to 10% of respondents are employed part time or as freelancers.

Exercise: Add a new column Employment Type which contains values Enthusiast (student or not employed but looking for work), Professional (employed full-time, part-time or freelancing) and Other (not employed or retired). For each of the graphs that follow, show a comparison between Enthusiast and Professional.
"""

survey_df.Employment.value_counts()

employment_type_map = {
    'Student': 'Enthusiast',
    'Not employed, but looking for work': 'Enthusiast',
    'Employed full-time': 'Professional',
    'Independent contractor, freelancer, or self-employed': 'Professional',
    'Employed part-time': 'Professional',
    'Not employed, and not looking for work': 'Other',
    'Retired': 'Other'
}

survey_df['EmploymentType'] = survey_df.Employment.map(employment_type_map)

print('Value counts for the new employment type column:')
print(survey_df.EmploymentType.value_counts())

employment_type_counts = survey_df['EmploymentType'].value_counts()
employment_type_counts

plt.figure(figsize=(10, 6))
sns.barplot(
    x=employment_type_counts.index,
    y=employment_type_counts.values,
    palette='magma'
)
plt.title('Distribution of Employment Types')
plt.xlabel('Employment Type')
plt.ylabel('Number of respondents')

for index, values in enumerate(employment_type_counts):
  plt.text(index, values + 100, str(values), ha='center', va='bottom')

plt.tight_layout()
plt.show()

"""The DevType field contains information about the roles held by respondents. Since the question allows multiple answers, the column contains lists of values separated by, which makes it a bit harder to analyze directly."""

schema.DevType

survey_df.DevType.value_counts()

survey_df.DevType.unique()

def split_multicolumn(col_series):
  result_df = col_series.to_frame()
  options = []

  #iterate over the column
  for idex, value in col_series[col_series.notnull()].items():
    #break each value into list of options
    for option in value.split(';'):
      if not option in result_df.columns:
        options.append(option)
        result_df[option] = False
      #mark the value in the option column as true
      result_df.at[idex, option] = True
  return result_df[options]

dev_type_df = split_multicolumn(survey_df.DevType)
dev_type_df

dev_type_totals = dev_type_df.sum().sort_values(ascending=False)
dev_type_totals

"""**Exercise 7**

As one might expect, the most common roles include "Developer" in the name.

Exercises:

Can you figure out what percentage of respondents work in roles related to data science?

Which role has the highest percentage of women?

We've only explore a handful of columns from the 20 columns that we selected. Explore and visualize the remaining columns using the empty cells below.

***1. Percentage of Respondents in Data Science Roles***
"""

datascience_roles_sum = dev_type_totals.loc[[
    'Data scientist or machine learning specialist',
    'Engineer, data',
    'Data or business analyst'
]].sum()
datascience_roles_sum

total_dev_types = dev_type_totals.sum()

percentage_datascience_roles = (datascience_roles_sum/total_dev_types)*100
percentage_datascience_roles

print(f'Total respondents in data science related roles: \n {datascience_roles_sum}')
print(f'Total respondents who specified a dev type: \n{total_dev_types}')
print(f'Percentage of respondents who work in data science related roles: \n {percentage_datascience_roles}')

ds_data = pd.DataFrame({
    'Role Type': ['Data Science roles', 'Other roles'],
    'Percentage': [percentage_datascience_roles, 100 -percentage_datascience_roles]
})

plt.figure(figsize=(12,8))
sns.barplot(
    x='Role Type',
    y='Percentage',
    hue='Role Type',
    data=ds_data,
    palette='turbo',
    legend=False
)

plt.title('Percentage of respondents in data Science related roles')
plt.xlabel('Role Type')
plt.ylabel('Percentage');

for index, value in enumerate(ds_data['Percentage']):
  plt.text(index, value + 1, f'{value:.2f}%', ha='center', va='bottom')

plt.ylim(0,100)
plt.show()

"""***2. Role with the Highest Percentage of Women***"""

women_series = survey_df.Gender.isin(['Woman'])
women_series

dev_type_gender_df = dev_type_df.copy()
dev_type_gender_df['IsWoman'] = women_series

women_percentages_by_role = {}

for role in dev_type_gender_df.columns[:-1]:
  total_in_role = dev_type_gender_df[role].sum()
  women_in_role = dev_type_gender_df[(dev_type_gender_df[role] == True) &dev_type_gender_df['IsWoman'] == True][role].sum()

  if total_in_role > 0:
    percentage = (women_in_role/total_in_role)*100
    women_percentages_by_role[role] = percentage

women_percentage_series = pd.Series(women_percentages_by_role).sort_values(ascending=False)
women_percentage_series

highest_percentage_role = women_percentage_series.idxmax()
highest_percentage_value = women_percentage_series.max()

print(f'Role with the highest perecentage of women is {highest_percentage_role} with a percentage of {highest_percentage_value}')

total_roles_by_women = women_percentage_series.head(10)

plt.figure(figsize=(12,8))
sns.barplot(
    x=total_roles_by_women.values,
    y=total_roles_by_women.index,
    palette='magma'
)
plt.title('Top 10 Roles by Percentage of Women')
plt.xlabel('Percentage of Women %')
plt.ylabel('Role')

for index, value in enumerate(total_roles_by_women.values):
  plt.text(value, index, f'{value:.2f}%', ha='left', va='center')

plt.tight_layout()
plt.show()

"""**Exercise 8**

We have only explored a handfull of columns fom the 20 coluns that we selected.
Explore and visualize the remaining columns

***1. Hobbyist Analysis***
"""

hobbyist_counts = survey_df.Hobbyist.value_counts(normalize=True)*100
hobbyist_counts

plt.figure(figsize=(6,6));
plt.title('Are you a Hobbyist?');
plt.pie(
    hobbyist_counts,
    labels=hobbyist_counts.index,
    autopct='%1.1f%%',
    startangle=100,
    colors=sns.color_palette('turbo')
);

"""***2. Job Satisfaction Analysis***"""

jobsat_count = survey_df.JobSat.value_counts().sort_values()
jobsat_count

plt.figure(figsize=(12,6))
sns.barplot(
    x=jobsat_count.values,
    y=jobsat_count.index,
    hue=jobsat_count.index,
    palette='magma'
)
plt.title('Job Satisfaction Distribution')
plt.xlabel('Number of Respondents')
plt.ylabel('Job satisfactoon level')

for index, value in enumerate(jobsat_count.values):
  plt.text(value + 100, index, str(value), va='center')

plt.tight_layout()
plt.show()

"""***Q. Which were the most popular programming languages in 2020?***"""

schema.LanguageWorkedWith

schema.LanguageDesireNextYear

survey_df.LanguageWorkedWith

languages_worked_df = split_multicolumn(survey_df.LanguageWorkedWith)
languages_worked_df

languages_worked_percentages = languages_worked_df.mean().sort_values(ascending=False)*100
languages_worked_percentages

plt.figure(figsize=(12,8));
sns.barplot(
    x=languages_worked_percentages.values,
    y=languages_worked_percentages.index,
    hue=languages_worked_percentages.index,
    palette='hls'
);
plt.title('Languages used in the past year');
plt.xlabel('Count');
plt.ylabel('Language');

"""Perhaps not surprisingly, Javascript & HTML/CSS comes out at the top as web development is one of the most sought skills today and it also happens to be one of the easiest to get started with. SQL is recessary for working with relational databases, so it's no surprise that most programmers work with SQL on a regular basis. For other forms of development, Python seems be the popular choice, beating out Java, which was the industry standard for server & application development for over 2 decades.

**Exercise 9**

Exercises:

What are the most common languages used by students? How does the list compare with the most common languages used by professional developers?

What are the most common languages among respondents who do not describe themselves as "Developer, front-end"?

What are the most common languages among respondents who work in fields related to data science?

What are the most common languages used by developers older than 35 years of age?

What are the most common languages used by developers in your home country?

***1.Languages Used by Students vs. Professionals***
"""

student_mask = survey_df.EmploymentType == 'Enthusiast'
student_mask

student_languages_df = languages_worked_df[student_mask]
student_languages_df

student_languages_percentages = student_languages_df.mean().sort_values(ascending=False)*100
student_languages_percentages

plt.figure(figsize=(12,8));
sns.barplot(
    x=student_languages_percentages.values,      #magma, inferno, plasma, cividis, mako, rocket, and turbo
    y=student_languages_percentages.index,
    hue=student_languages_percentages.index,
    palette='cividis'
);
plt.title('Most common languages among students');
plt.xlabel('percentages');
plt.ylabel('Languages');

professionals_mask = survey_df.EmploymentType == 'Professional'
professionals_mask

professional_languages_df = languages_worked_df[professionals_mask]
professional_languages_df

professional_languages_percentages = professional_languages_df.mean().sort_values(ascending=False)*100
professional_languages_percentages

plt.figure(figsize=(12,8));
sns.barplot(
    x=professional_languages_percentages.values,      #magma, inferno, plasma, cividis, mako, rocket, and turbo
    y=professional_languages_percentages.index,
    hue=professional_languages_percentages.index,
    palette='inferno'
);
plt.title('Most common languages among professionals');
plt.xlabel('Count');
plt.ylabel('Percentage');

"""***2. Languages Among Non-Front-end Developers***"""

non_frontend_mask = ~dev_type_df['Developer, front-end']
non_frontend_mask

non_frontend_languages_df = languages_worked_df[non_frontend_mask]
non_frontend_mask

non_frontend_languages_percentages = non_frontend_languages_df.mean().sort_values(ascending=False)*100
non_frontend_languages_percentages

plt.figure(figsize=(12,8));
sns.barplot(
    x=non_frontend_languages_percentages.values,      #magma, inferno, plasma, cividis, mako, rocket, and turbo
    y=non_frontend_languages_percentages.index,
    hue=non_frontend_languages_percentages.index,
    palette='rocket'
);
plt.title('Most common languages among non-front-end developers');
plt.xlabel('percentages');
plt.ylabel('Languages');

"""***3. Languages in Data Science Fields***"""

ds_roles = [
    'Data scientist or machine learning specialist',
    'Engineer, data',
    'Data or business analyst'
]

ds_mask = dev_type_df[ds_roles].any(axis=1)
ds_languages_df = languages_worked_df[ds_mask]
ds_languages_df.head(10)

ds_languages_percentages = ds_languages_df.mean().sort_values(ascending=False)*100
ds_languages_percentages.head(10)

plt.figure(figsize=(12,8));
sns.barplot(
    x=ds_languages_percentages.values,      #magma, inferno, plasma, cividis, mako, rocket, and turbo
    y=ds_languages_percentages.index,
    hue=ds_languages_percentages.index,
    palette='inferno'
);
plt.title('Most common languages among data science professionals');
plt.xlabel('percentages');
plt.ylabel('Languages');

"""***4. Languages Among Developers Older Than 35***"""

older_devs_mask = survey_df.Age >= 35
older_devs_languages_df = languages_worked_df[older_devs_mask]
older_devs_percentages = older_devs_languages_df.mean().sort_values(ascending=False)*100
older_devs_percentages.head(10)

plt.figure(figsize=(12,8));
sns.barplot(
    x=older_devs_percentages.values,      #magma, inferno, plasma, cividis, mako, rocket, and turbo
    y=older_devs_percentages.index,
    hue=older_devs_percentages.index,
    palette='pastel'
);
plt.title('Most common languages among Older Professional Developers');
plt.xlabel('percentages');
plt.ylabel('Languages');

"""***5. Languages in Your Home Country (India)***"""

india_mask = survey_df.Country == 'India'
india_languages_df = languages_worked_df[india_mask]
india_languages_percentages = india_languages_df.mean().sort_values(ascending=False)*100
india_languages_percentages.head(10)

plt.figure(figsize=(12,8));
sns.barplot(
    x=india_languages_percentages.values,      #magma, inferno, plasma, cividis, mako, rocket, and turbo
    y=india_languages_percentages.index,
    hue=india_languages_percentages.index,
    palette='mako'
);
plt.title('Most common languages in your Home Country (India)');
plt.xlabel('percentages');
plt.ylabel('Languages');

"""***Q. Which languages are the most people interested to learn over the next year?***"""

languages_interested_df = split_multicolumn(survey_df.LanguageDesireNextYear)
languages_interested_percentages = languages_interested_df.mean().sort_values(ascending=False)*100
languages_interested_percentages

plt.figure(figsize=(12,8));
sns.barplot(
    x=languages_interested_percentages.values,
    y=languages_interested_percentages.index,
    hue=languages_interested_percentages.index,
    palette='magma'
);
plt.title('Languages interested in learning next year');
plt.xlabel('Count');
plt.ylabel('Language');

"""**Exercise 10**

Once again, it's not surprising that Python is the language most people are interested in learning -since it is an easy-to-learn general purpose programming language well suited for a variety of domains: application development, numerical computing, data analysis, machine learning, big data, cloud automation, web scraping, scripting etc. etc. We're using Python for this very analysis, so we're in good company!

Exercises: Repeat all the exercises for the previous question, replacing "most common languages" with "languages people are interested in learning/using".

***1. Languages of Interest for Students vs. Professionals***
"""

student_mask = survey_df.EmploymentType == 'Enthusiast'
student_languages_df = languages_interested_df[student_mask]
student_languages_percentages = student_languages_df.mean().sort_values(ascending=False)*100
student_languages_percentages.head(10)

pip install squarify

import squarify

plt.figure(figsize=(10,6));
squarify.plot(
    sizes=student_languages_percentages.values,
    label=student_languages_percentages.index,                                    #magma, inferno, plasma, cividis, mako, rocket, and turbo
    color=sns.color_palette('turbo', len(student_languages_percentages)),
    alpha=0.8
);
plt.title('Most desired languages among students');
plt.axis('off');
plt.show()

professionals_mask = survey_df.EmploymentType == 'Professional'
professional_languages_df = languages_interested_df[professionals_mask]
professionals_languages_percentages = professional_languages_df.mean().sort_values(ascending=False)*100
professionals_languages_percentages.head(10)

plt.figure(figsize=(12,8));
plt.hlines(
    y=professionals_languages_percentages.index,
    xmin=0,
    xmax=professionals_languages_percentages.values,
    color='gray'                     #magma, inferno, plasma, cividis, mako, rocket, and turbo
);
plt.plot(
    professionals_languages_percentages.values,
    professionals_languages_percentages.index,
    'o', color='crimson'
)
plt.title('Most desired languages among professionals:');
plt.xlabel('Count');
plt.ylabel('Language');

"""***2. Languages of Interest Among Non-Front-end Developers***"""

non_front_end_mask = ~dev_type_df['Developer, front-end']
non_front_end_languages_df = languages_interested_df[non_front_end_mask]
non_front_end_languages_percentages = non_front_end_languages_df.mean().sort_values(ascending=False)*100
non_front_end_languages_percentages.head(10)

plt.figure(figsize=(12,8));
sns.stripplot(
    x=non_front_end_languages_percentages.values,
    y=non_front_end_languages_percentages.index,
    hue=non_front_end_languages_percentages.index,
    palette='dark:dodgerblue', size=10                 #magma, inferno, plasma, cividis, mako, rocket, and turbo
);
plt.title('Most desired languages among non-front-end developers');
plt.xlabel('Count');
plt.ylabel('Language');

"""***3. Languages of Interest in Data Science Fields***"""

ds_roles = [
    'Data scientist or machine learning specialist',
    'Engineer, data',
    'Data or business analyst'
]

ds_mask = dev_type_df[ds_roles].any(axis=1)
ds_languages_df = languages_interested_df[ds_mask]
ds_languages_percentages = ds_languages_df.mean().sort_values(ascending=False)*100
ds_languages_percentages.head(10)

top_10_languages = ds_languages_percentages.head(10)

plt.figure(figsize=(12,8));
plt.pie(
    top_10_languages.values,
    labels=top_10_languages.index,
    autopct='%1.1f%%',
    startangle=180,
    colors = sns.color_palette('plasma', len(top_10_languages))              #magma, inferno, plasma, cividis, mako, rocket, and turbo
);
plt.title('Most desired languages among Data science Professionals');
plt.xlabel('Count');
plt.ylabel('Language');

"""***4.Languages of Interest Among Developers Older Than 35***"""

older_devs_mask = survey_df.Age >=35
older_devs_languages_df = languages_interested_df[older_devs_mask]
older_devs_percentages = older_devs_languages_df.mean().sort_values(ascending=False)*100
older_devs_percentages.head(10)

top_15_interested_languages = older_devs_percentages.head(15)

plt.figure(figsize=(10,6))
plt.hlines(
    y=top_15_interested_languages.index,
    xmin=0,
    xmax=top_15_interested_languages.values,
    color='gray'
)
sns.scatterplot(
    y=top_15_interested_languages.index,
    x=top_15_interested_languages.values,
    s=150,
    color='steelblue',
    alpha=0.8
)
plt.title('Most desired languages among developers older than 35')
plt.xlabel('Percentage')
plt.ylabel('Language')
plt.grid(axis='x', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

"""***5. Languages of Interest in Your Home Country (India)***"""

india_mask = survey_df.Country == 'India'
india_languages_df = languages_interested_df[india_mask]
india_languages_percentages = india_languages_df.mean().sort_values(ascending=False)*100
india_languages_percentages.head(10)

top15_indian_languages = india_languages_percentages.head(15)

plt.figure(figsize=(10,6))
plt.hlines(
    y=top15_indian_languages.index,
    xmin=0,
    xmax=top15_indian_languages.values,
    color='gray'
)
sns.scatterplot(
    y=top15_indian_languages.index,
    x=top15_indian_languages.values,
    s=150,
    color='red',
    alpha=0.8
)
plt.title('Most desired languages in Your Home Country (India)')
plt.xlabel('Percentage')
plt.ylabel('Language')
plt.grid(axis='x', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

"""***Q.Which are the most loved languages ie. a high percentage of people who have used the language want to continue learning and using it over the next year?***"""

languages_loved_df = languages_worked_df & languages_interested_df
languages_loved_df

True & True

languages_loved_percentages = (languages_loved_df.sum() *100 / languages_worked_df.sum()).sort_values(ascending=False)
languages_loved_percentages

plt.figure(figsize=(10,8));
sns.barplot(
    x=languages_loved_percentages.values,
    y=languages_loved_percentages.index,
    hue=languages_loved_percentages.index,
    palette='mako'
);
plt.title('Languages Loved');
plt.xlabel('Count');
plt.ylabel('Language');

"""**Exercise 10**

Rust has been StackOverflow's most-loved language for 4 years in a row, followed by TypeScript which has gained a lot of popularity in the past few years as a good alternative to JavaScript for web development.

Python features at number 3, despite already being one of the most widely-used languages in world. This is testament to the fact the language has solid foundation, is really easy to learn & use, has a strong ecosystem of libraries for various and massive worldwide community of developers to enjoy using it.

Exercises: What are the most dreaded languages i.e. languages which people have used in the past year, but do not want to learn/use over the next year. Hint: languages_interested_df
"""

languages_dreaded_df = languages_worked_df & ~languages_interested_df
languages_dreaded_df

languages_dreaded_percentages = (languages_dreaded_df.sum() * 100 / languages_worked_df.sum()).sort_values(ascending=False)
languages_dreaded_percentages.head(10)

plt.figure(figsize=(10,6))
sns.barplot(
    x=languages_dreaded_percentages.values,
    y=languages_dreaded_percentages.index,
    hue=languages_dreaded_percentages.index,
    palette='mako'
)
plt.title('Languages Dreaded');
plt.xlabel('Count');
plt.ylabel('Language');

"""***Q. In which countries do developers work the highest number of hours per week? Consider countries with more than 250 responses only***"""

survey_df.groupby('Country')[['WorkWeekHrs', 'Age']].mean()

countries_df = survey_df.groupby('Country')[['WorkWeekHrs']].mean().sort_values('WorkWeekHrs',ascending=False)
countries_df

high_response_countries_df = countries_df.loc[survey_df.Country.value_counts() > 250].head(15)
high_response_countries_df

"""**Exercise 11**

The Asian countries like Iran, China & Israel have the highest working hours, followed by the United States. However, there isn't too much variation overall and the average working hours seem to be around 40 hours per week.

Exercises:

How to the average work hours compare across continents? You may find this list of countries in each continent useful.

Which role has the highest average number of hours worked per week? Which role has the lowest?

How do the hours worked compare between freelancers and developers working full-time?

***1. Average Work Hours by Continent***
"""

pip install pycountry_convert

import pycountry_convert as pc

def get_continent(country_name):
  if not isinstance(country_name, str) :
    return 'Not found'
  try:
    country_alpha2 = pc.country_name_to_country_alpha2(country_name, cn_name_format='default')
    continent_code = pc.country_alpha2_to_continent_code(country_alpha2)
    continent_name = pc.convert_continent_code_to_continent_name(continent_code)
    return continent_name
  except KeyError:
    return 'Not Found'
  except Exception as e:
    print(e)
    return 'Not Found'

survey_df['Continent'] = survey_df['Country'].apply(get_continent)
continent_workHours = survey_df.groupby('Continent')['WorkWeekHrs'].mean().sort_values(ascending=False)
print("Average work hours by continent (using pycountry-convert):")
print(continent_workHours)

plt.figure(figsize=(10, 6))
sns.barplot(
    x=continent_workHours.index,
    y = continent_workHours.values,
    palette='Set1'
)

plt.title('Average Work Hours by Continent')
plt.ylabel('Average Work Hours per week')
plt.xlabel('Continent')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""***2. Roles with Highest and Lowest Average Work Hours***"""

dev_roles = dev_type_df.columns.tolist()

role_work_hours = {}

for role in dev_roles:
  role_mask = dev_type_df[role] == True
  average_hours = survey_df[role_mask]['WorkWeekHrs'].mean()
  role_work_hours[role] = average_hours

role_work_hours_series = pd.Series(role_work_hours).sort_values(ascending=False)
print('Average work hours by role : ')
print(role_work_hours_series)

print('\n Role with the highest average work hours : ')
print(role_work_hours_series.idxmax())

print('\n Role with the lowest average work hours : ')
print(role_work_hours_series.idxmin())

"""***3. Work Hours for Freelancers vs. Full-time Developers***"""

full_time_average = survey_df[survey_df.Employment == 'Employed full-time']['WorkWeekHrs'].mean()
print(f'Average work week hours for full timers is : {full_time_average:.2f}')

freelancer_average = survey_df[survey_df.Employment == 'Independent contractor, freelancer, or self-employed']['WorkWeekHrs'].mean()
print(f'Average work week hours for freelancers is : {freelancer_average:.2f}')

work_hours_comparison = pd.DataFrame({
    'Employment Type' : ['Full-time', 'Freelancer'],
    'Average work Hours': [full_time_average, freelancer_average]
})

plt.figure(figsize=(10, 6))
sns.barplot(
    x='Employment Type',
    y = 'Average work Hours',
    data=work_hours_comparison,
    palette='Set1'
)

plt.title('Average Work Hours: Full-time vs. Freelancers')
plt.ylabel('Average Work Hours')
plt.xlabel('Employment Type')
plt.show()

"""***Q.How important is it to start young to build a career in programming?***"""

schema.YearsCodePro

schema.YearsCode

sns.scatterplot(x='Age', y='YearsCodePro', hue='Hobbyist', data=survey_df);
plt.xlabel('Age in years');
plt.ylabel("Years of professional coding experience");

plt.figure(figsize=(8,8))
sns.histplot(data=survey_df, x='Age1stCode', kde=True, palette='turbo');
plt.title(schema.Age1stCode);
plt.xlabel('Age')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

"""**Exercise 12**

As you might expect, most people seem to have had some exposure to programming before the age of 40, but there are people of all ages and walks of life who are learning to code.

Exercises:

How does experience change opinions & preferences? Repeat the entire analysis while comparing the responses of people who have more than 10 years of professional programming experience v.s. those who don't. Do you see any interesting trends?

Compare the years of professional coding experience across different genders.
"""

survey_df['YearsCodePro'] = pd.to_numeric(survey_df.YearsCodePro, errors='coerce')

survey_df['ExperienceGroup'] = np.where(
    survey_df.YearsCodePro >= 10,
    '10+ Years',
    'Less Than 10 Years'
)

experienceGroup_df = survey_df.dropna(subset=['JobSat', 'ExperienceGroup']).copy()

plt.figure(figsize=(10,6));
sns.boxplot(
    hue='ExperienceGroup',
    y='JobSat',
    data=experienceGroup_df,
    palette='Set1'
);
plt.title('Job Satisfaction by Professional Experience')
plt.xlabel('Number of Respondents')
plt.ylabel('Job Satisfaction')
plt.legend(title='Professional Experience Group')
plt.tight_layout()
plt.show()

satisfaction_crosstab = pd.crosstab(
    index=experienceGroup_df['JobSat'],
    columns=experienceGroup_df['ExperienceGroup'],
    normalize='columns'
)*100
print("Job Satisfaction Percentage by Experience Group:")
print(satisfaction_crosstab)

"""***2. Compare Professional Experience Across Genders***"""

proExp_df = survey_df.dropna(subset=['YearsCodePro', 'Gender']).copy()

proExp_df['Gender_Cleaned'] = proExp_df['Gender'].apply(
    lambda x: 'Man' if x == 'Man' else ('Woman' if x=='Woman' else 'Other')
)

plt.figure(figsize=(10,6));
sns.boxplot(
    hue='Gender_Cleaned',
    y='YearsCodePro',
    data=proExp_df,
    palette='plasma'
);
plt.title('Professional Experience by Gender')
plt.xlabel('Gender')
plt.ylabel('Years of Professional Coding Experience')
plt.show()
median_years_by_gender  = proExp_df.groupby('Gender_Cleaned')['YearsCodePro'].median()
print("Median years of professional coding experience by gender:")
print(median_years_by_gender)

